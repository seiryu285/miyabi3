<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ITEM - MIYABI NFT Collection</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    canvas { display: block; }
    #loading, #blocker, #instructions, #mobile-controls { position: absolute; }
    #loading, #blocker { top: 0; left: 0; width: 100%; height: 100%; }
    #loading { background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; }
    #loading-bar { width: 0%; height: 4px; background: #fff; transition: width 0.5s ease; }
    #blocker { background-color: rgba(0,0,0,0.5); }
    #instructions { top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #fff; }
    /* モバイル用操作ボタン */
    #mobile-controls { bottom: 20px; left: 50%; transform: translateX(-50%); display: none; z-index: 100; }
    .control-button { 
      width: 60px; 
      height: 60px; 
      background-color: rgba(255,255,255,0.7); 
      border: none; 
      border-radius: 30px; 
      margin: 0 10px; 
      font-size: 28px; 
      color: #000; 
      touch-action: manipulation;
    }
    .control-button:active { background-color: rgba(255,255,255,0.9); }
    #error-message {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(255, 0, 0, 0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      display: none;
      z-index: 1001;
    }
    .artwork-info {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 15px;
      border-radius: 8px;
      display: none;
      z-index: 1000;
      max-width: 80%;
      text-align: center;
    }
    .loading-text {
      color: white;
      font-size: 16px;
      margin-top: 10px;
      text-align: center;
    }
    .progress-container {
      width: 200px;
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      overflow: hidden;
      margin-top: 10px;
    }
    .navigation {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      background-color: #333;
      color: #fff;
      padding: 1em;
      text-align: center;
    }
    .nav-content {
      max-width: 800px;
      margin: 0 auto;
    }
    .nav-content a {
      color: #fff;
      text-decoration: none;
      margin: 0 20px;
    }
    .nav-content a.active {
      color: #ccc;
    }
    .model-gallery-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      height: 80%;
      background-color: #fff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
    }
    .model-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-gap: 20px;
    }
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: none;
    }
    .modal-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #fff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
    }
    .close {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 24px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <nav class="navigation">
    <div class="nav-content">
      <a href="index.html">HOME</a>
      <a href="gallery.html">GALLERY</a>
      <a href="model-gallery.html" class="active">ITEM</a>
      <a href="about.html">ABOUT</a>
    </div>
  </nav>

  <div class="model-gallery-container">
    <div id="modelGallery" class="model-grid">
      <!-- Models will be populated by JavaScript -->
    </div>
  </div>

  <!-- Model Viewer Modal -->
  <div id="modelModal" class="modal">
    <div class="modal-content">
      <span class="close">&times;</span>
      <div class="modal-body">
        <model-viewer id="activeModel"
          camera-controls
          auto-rotate
          shadow-intensity="1"
          exposure="1"
          style="width: 100%; height: 500px;">
        </model-viewer>
        <div id="modelInfo"></div>
      </div>
    </div>
  </div>

  <!-- Three.js 本体と PointerLockControls -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
  
  <script>
    let camera, scene, renderer, controls;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let prevTime = performance.now();
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    let raycaster;
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // サンプルのアートワーク
    const artworks = [
      { url: 'https://i.postimg.cc/KvfgYszt/2024-08-07-153234.png', title: '作品1', description: '説明1' },
      { url: 'https://i.postimg.cc/KYkKJG55/2024-08-03-194532.png', title: '作品2', description: '説明2' },
      { url: 'https://i.postimg.cc/KvfgYszt/2024-08-07-153234.png', title: '作品1', description: '説明1' },
    ];
    
    const immersiveSpaces = [];
    let currentSpace = 'main';
    let isTransitioning = false;
    let assetsLoaded = false;
    let totalAssets = 0;
    let loadedAssets = 0;
    
    // エラー表示
    function showError(message) {
      const errorDiv = document.getElementById('error-message');
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
      setTimeout(() => { errorDiv.style.display = 'none'; }, 5000);
    }
    
    const textureLoader = new THREE.TextureLoader();
    
    // テクスチャ読み込み（Promise 化）
    function loadTexture(url) {
      totalAssets++;
      return new Promise((resolve, reject) => {
        textureLoader.load(url, texture => {
          loadedAssets++;
          updateLoadingProgress();
          resolve(texture);
        }, undefined, error => {
          console.error('テクスチャ読み込みエラー:', url, error);
          showError('テクスチャの読み込みに失敗しました');
          reject(error);
        });
      });
    }
    
    // 動画読み込み（Promise 化）
    async function loadVideo(fileName) {
      totalAssets++;
      return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        video.loop = true;
        video.muted = true;
        video.playsInline = true;
        video.crossOrigin = 'anonymous';
        video.addEventListener('loadeddata', () => {
          loadedAssets++;
          updateLoadingProgress();
          console.log('動画の読み込み完了:', fileName);
          resolve(video);
        });
        video.addEventListener('error', (e) => {
          console.error('動画読み込みエラー:', e);
          showError('動画の読み込みに失敗しました');
          reject(e);
        });
        video.src = `./assets/${fileName}`;
        video.play().catch(error => {
          console.warn("自動再生失敗:", error);
          document.addEventListener('click', () => {
            video.play().catch(e => console.error('再生失敗:', e));
          }, { once: true });
        });
      });
    }
    
    function updateLoadingProgress() {
      const progress = (loadedAssets / totalAssets) * 100;
      document.getElementById('loading-bar').style.width = `${progress}%`;
    }
    
    function createMuseumEnvironment() {
      const floorGeometry = new THREE.CircleBufferGeometry(20, 32);
      const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xF0F0F0 });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);
      
      const wallGeometry = new THREE.CylinderBufferGeometry(20, 20, 10, 32, 1, true);
      const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, side: THREE.BackSide });
      const wall = new THREE.Mesh(wallGeometry, wallMaterial);
      wall.position.y = 5;
      scene.add(wall);
      
      const ceilingGeometry = new THREE.CircleBufferGeometry(20, 32);
      const ceilingMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
      const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
      ceiling.position.y = 10;
      ceiling.rotation.x = Math.PI / 2;
      scene.add(ceiling);
    }
    
    async function createArtworks() {
      for (let i = 0; i < artworks.length; i++) {
        const artwork = artworks[i];
        try {
          const texture = await loadTexture(artwork.url);
          const artGeometry = new THREE.PlaneBufferGeometry(3, 5);
          const artMaterial = new THREE.MeshBasicMaterial({ map: texture });
          const art = new THREE.Mesh(artGeometry, artMaterial);
          
          const angle = (i / artworks.length) * Math.PI * 2;
          art.position.set(
            Math.cos(angle) * 14,
            4,
            Math.sin(angle) * 14
          );
          art.lookAt(0, 4, 0);
          scene.add(art);
          
          createArtworkPlate(artwork, art.position.clone(), art.getWorldDirection(new THREE.Vector3()));
          createInteractionArea(i, angle);
        } catch (error) {
          console.error(`アートワーク ${i+1} の作成に失敗:`, error);
        }
      }
    }
    
    function createArtworkPlate(artwork, position, direction) {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 512;
      canvas.height = 256;
      context.fillStyle = 'rgba(240,240,240,0.8)';
      context.fillRect(0, 0, canvas.width, canvas.height);
      context.font = 'bold 24px Arial';
      context.fillStyle = 'black';
      context.textAlign = 'center';
      context.fillText(artwork.title, canvas.width/2, 40);
      context.font = '16px Arial';
      const lines = getLines(context, artwork.description, canvas.width - 40);
      lines.forEach((line, i) => {
        context.fillText(line, canvas.width/2, 80 + i * 20);
      });
      
      const texture = new THREE.CanvasTexture(canvas);
      const plateGeometry = new THREE.PlaneBufferGeometry(2, 1);
      const plateMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
      const plate = new THREE.Mesh(plateGeometry, plateMaterial);
      plate.position.copy(position).add(direction.clone().normalize().multiplyScalar(0.1));
      plate.position.y = 1;
      plate.lookAt(plate.position.clone().add(direction));
      scene.add(plate);
    }
    
    function createInteractionArea(index, angle) {
      const geometry = new THREE.CircleBufferGeometry(2, 32);
      const material = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.2, alphaTest: 0.5 });
      const area = new THREE.Mesh(geometry, material);
      area.rotation.x = -Math.PI / 2;
      area.position.set(Math.cos(angle)*12, 0.01, Math.sin(angle)*12);
      area.userData = { artworkIndex: index };
      scene.add(area);
    }
    
    function getLines(context, text, maxWidth) {
      const words = text.split(" ");
      const lines = [];
      let currentLine = words[0];
      for (let i = 1; i < words.length; i++) {
        const word = words[i];
        const width = context.measureText(currentLine + " " + word).width;
        if (width < maxWidth) {
          currentLine += " " + word;
        } else {
          lines.push(currentLine);
          currentLine = word;
        }
      }
      lines.push(currentLine);
      return lines;
    }
    
    async function createImmersiveSpaces() {
      for (let i = 0; i < artworks.length; i++) {
        const artwork = artworks[i];
        const space = new THREE.Group();
        space.visible = false;
        
        const bgGeometry = new THREE.SphereBufferGeometry(30, 32, 32);
        const bgMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, side: THREE.BackSide });
        const background = new THREE.Mesh(bgGeometry, bgMaterial);
        space.add(background);
        
        try {
          const texture = await loadTexture(artwork.url);
          const displayGeometry = new THREE.PlaneBufferGeometry(20, 30);
          const displayMaterial = new THREE.MeshBasicMaterial({ map: texture });
          const display = new THREE.Mesh(displayGeometry, displayMaterial);
          space.add(display);
        } catch (error) {
          console.error('没入空間テクスチャエラー:', error);
        }
        
        immersiveSpaces.push(space);
        scene.add(space);
      }
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    let lastFrameTime = 0;
    function animate(time) {
      requestAnimationFrame(animate);
      if (!assetsLoaded) return;
      
      const delta = (time - prevTime) / 1000;
      prevTime = time;
      
      velocity.x -= velocity.x * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;
      
      direction.z = Number(moveForward) - Number(moveBackward);
      direction.x = Number(moveRight) - Number(moveLeft);
      direction.normalize();
      
      if (moveForward || moveBackward) velocity.z -= direction.z * 200.0 * delta;
      if (moveLeft || moveRight) velocity.x -= direction.x * 200.0 * delta;
      
      if (isMobile) {
        camera.translateX(velocity.x * delta);
        camera.translateZ(velocity.z * delta);
      } else {
        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);
      }
      
      const cameraPosition = camera.position;
      const dist = Math.sqrt(cameraPosition.x * cameraPosition.x + cameraPosition.z * cameraPosition.z);
      if (dist > 19) {
        const ratio = 19 / dist;
        cameraPosition.x *= ratio;
        cameraPosition.z *= ratio;
      }
      
      camera.position.y = 1.6;
      
      raycaster.ray.origin.copy(camera.position);
      raycaster.ray.origin.y -= 1;
      const intersections = raycaster.intersectObjects(scene.children);
      if (intersections.length > 0) {
        const intersection = intersections[0];
        if (intersection.object.geometry instanceof THREE.CircleBufferGeometry && intersection.distance < 2) {
          const artworkIndex = intersection.object.userData.artworkIndex;
          if (typeof artworkIndex !== 'undefined' && !isTransitioning) {
            enterImmersiveSpace(artworkIndex);
          }
        }
      } else if (currentSpace !== 'main' && !isTransitioning) {
        exitImmersiveSpace();
      }
      
      renderer.render(scene, camera);
    }
    
    function enterImmersiveSpace(index) {
      if (isTransitioning) return;
      isTransitioning = true;
      
      const targetPos = new THREE.Vector3(0, 1.6, 2);
      const duration = 1000;
      const startTime = performance.now();
      const startPos = camera.position.clone();
      
      function transition() {
        const now = performance.now();
        const progress = Math.min((now - startTime) / duration, 1);
        camera.position.lerpVectors(startPos, targetPos, progress);
        if (progress < 1) {
          requestAnimationFrame(transition);
        } else {
          completeTransition();
        }
      }
      
      function completeTransition() {
        scene.background = null;
        scene.children.forEach(child => {
          if (child !== immersiveSpaces[index] && !(child instanceof THREE.Light)) {
            child.visible = false;
          }
        });
        const space = immersiveSpaces[index];
        if (space) {
          space.visible = true;
          const display = space.children.find(child => child instanceof THREE.Mesh && child.material.map);
          if (display) {
            display.position.set(0, 1.6, -1);
            display.lookAt(camera.position);
          }
          currentSpace = 'artwork' + index;
        }
        isTransitioning = false;
      }
      
      transition();
    }
    
    function exitImmersiveSpace() {
      if (isTransitioning) return;
      isTransitioning = true;
      
      const targetPos = new THREE.Vector3(0, 1.6, 5);
      const duration = 1000;
      const startTime = performance.now();
      const startPos = camera.position.clone();
      
      function transition() {
        const now = performance.now();
        const progress = Math.min((now - startTime) / duration, 1);
        camera.position.lerpVectors(startPos, targetPos, progress);
        if (progress < 1) {
          requestAnimationFrame(transition);
        } else {
          completeTransition();
        }
      }
      
      function completeTransition() {
        scene.background = new THREE.Color(0xFFFFFF);
        scene.children.forEach(child => {
          if (!(child instanceof THREE.Light)) {
            child.visible = true;
          }
        });
        immersiveSpaces.forEach(space => {
          if (space) space.visible = false;
        });
        currentSpace = 'main';
        isTransitioning = false;
      }
      
      transition();
    }
    
    function onKeyDown(event) {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW': moveForward = true; break;
        case 'ArrowLeft':
        case 'KeyA': moveLeft = true; break;
        case 'ArrowDown':
        case 'KeyS': moveBackward = true; break;
        case 'ArrowRight':
        case 'KeyD': moveRight = true; break;
      }
    }
    
    function onKeyUp(event) {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW': moveForward = false; break;
        case 'ArrowLeft':
        case 'KeyA': moveLeft = false; break;
        case 'ArrowDown':
        case 'KeyS': moveBackward = false; break;
        case 'ArrowRight':
        case 'KeyD': moveRight = false; break;
      }
    }
    
    let touchStartX, touchStartY;
    function mobileTouchStart(event) {
      if (event.target.closest('.control-button')) return;
      event.preventDefault();
      if (event.touches.length === 1) {
        touchStartX = event.touches[0].pageX;
        touchStartY = event.touches[0].pageY;
      }
    }
    
    function mobileTouchMove(event) {
      if (event.target.closest('.control-button')) return;
      event.preventDefault();
      if (event.touches.length === 1) {
        const touchEndX = event.touches[0].pageX;
        const touchEndY = event.touches[0].pageY;
        const dx = touchEndX - touchStartX;
        const dy = touchEndY - touchStartY;
        camera.rotation.y -= dx * 0.008;
        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x - dy * 0.008));
        touchStartX = touchEndX;
        touchStartY = touchEndY;
      }
    }
    
    function mobileTouchEnd(event) {
      if (event.target.closest('.control-button')) return;
    }
    
    function optimizePerformance() {
      let lastTime = performance.now();
      let frames = 0;
      function checkFrameRate() {
        frames++;
        const now = performance.now();
        if (now > lastTime + 1000) {
          const fps = Math.round((frames * 1000) / (now - lastTime));
          // 低FPS時の対策（例: ピクセル比を下げるなど）を検討可能
          frames = 0;
          lastTime = now;
        }
        requestAnimationFrame(checkFrameRate);
      }
      checkFrameRate();
    }
    
    setInterval(cleanupUnusedResources, 60000);
    
    function improveAccessibility() {
      document.addEventListener('keydown', function(event) {
        if (event.key === 'Tab') {
          const focusable = document.querySelectorAll('button, [tabindex]:not([tabindex="-1"])');
          const first = focusable[0];
          const last = focusable[focusable.length - 1];
          if (event.shiftKey) {
            if (document.activeElement === first) {
              last.focus();
              event.preventDefault();
            }
          } else {
            if (document.activeElement === last) {
              first.focus();
              event.preventDefault();
            }
          }
        }
      });
      const ariaDesc = document.createElement('div');
      ariaDesc.setAttribute('aria-live', 'polite');
      ariaDesc.style.position = 'absolute';
      ariaDesc.style.left = '-9999px';
      document.body.appendChild(ariaDesc);
    }
    
    improveAccessibility();
    optimizePerformance();
    
    async function initAll() {
      try {
        await Promise.all([
          createMuseumEnvironment(),
          createArtworks(),
          createImmersiveSpaces(),
          createUltraHighResDome()
        ]);
        for (const space of immersiveSpaces) {
          await createUltraHighResDomeForSpace(space);
        }
        setupControls();
        setupEventListeners();
        
        renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" });
        renderer.setPixelRatio(isMobile ? 1 : window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        window.addEventListener('resize', onWindowResize, false);
        assetsLoaded = true;
        document.getElementById('loading').style.display = 'none';
        requestAnimationFrame(animate);
      } catch (error) {
        console.error('初期化エラー:', error);
        showError('初期化中にエラーが発生しました');
      }
    }
    
    function setupControls() {
      if (isMobile) {
        controls = new THREE.Object3D();
        camera.add(controls);
        document.getElementById('mobile-controls').style.display = 'block';
        setupMobileControls();
      } else {
        controls = new THREE.PointerLockControls(camera, document.body);
        setupDesktopControls();
      }
    }
    
    function setupMobileControls() {
      const btns = {
        forward: document.getElementById('forward'),
        backward: document.getElementById('backward'),
        left: document.getElementById('left'),
        right: document.getElementById('right')
      };
      Object.entries(btns).forEach(([dir, btn]) => {
        btn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          if (dir === 'forward') moveForward = true;
          else if (dir === 'backward') moveBackward = true;
          else if (dir === 'left') moveLeft = true;
          else if (dir === 'right') moveRight = true;
        }, { passive: false });
        btn.addEventListener('touchend', (e) => {
          e.preventDefault();
          if (dir === 'forward') moveForward = false;
          else if (dir === 'backward') moveBackward = false;
          else if (dir === 'left') moveLeft = false;
          else if (dir === 'right') moveRight = false;
        }, { passive: false });
      });
      document.getElementById('instructions').addEventListener('touchstart', () => {
        document.getElementById('blocker').style.display = 'none';
      }, { passive: false });
    }
    
    function setupDesktopControls() {
      controls.addEventListener('lock', () => {
        document.getElementById('blocker').style.display = 'none';
      });
      controls.addEventListener('unlock', () => {
        document.getElementById('blocker').style.display = 'block';
      });
      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      const blocker = document.getElementById('blocker');
      const instructions = document.getElementById('instructions');
      instructions.addEventListener('click', () => {
        controls.lock();
      });
    }
    
    function setupEventListeners() {
      if (isMobile) {
        document.addEventListener('touchstart', mobileTouchStart, { passive: false });
        document.addEventListener('touchmove', mobileTouchMove, { passive: false });
        document.addEventListener('touchend', mobileTouchEnd, { passive: false });
      }
    }
    
    mobileTouchStart(event) {
      if (event.target.closest('.control-button')) return;
      event.preventDefault();
      if (event.touches.length === 1) {
        touchStartX = event.touches[0].pageX;
        touchStartY = event.touches[0].pageY;
      }
    }
    
    mobileTouchMove(event) {
      if (event.target.closest('.control-button')) return;
      event.preventDefault();
      if (event.touches.length === 1) {
        const touchEndX = event.touches[0].pageX;
        const touchEndY = event.touches[0].pageY;
        const dx = touchEndX - touchStartX;
        const dy = touchEndY - touchStartY;
        camera.rotation.y -= dx * 0.008;
        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x - dy * 0.008));
        touchStartX = touchEndX;
        touchStartY = touchEndY;
      }
    }
    
    mobileTouchEnd(event) {
      if (event.target.closest('.control-button')) return;
    }
    
    setInterval(cleanupUnusedResources, 60000);
    optimizePerformance();
    improveAccessibility();
    
    // 初期化と読み込み開始
    initAll();
  </script>
</body>
</html>
